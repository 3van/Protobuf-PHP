<?php 
// DO NOT EDIT! Generated by Protobuf-PHP protoc plugin @package_version@ 
// Source: complex.proto 
//   Date: 2012-03-13 08:24:39 


namespace tests {

         
    class Complex extends \DrSlump\Protobuf\Message {
                                             
        /** @var \DrSlump\Protobuf\Descriptor */
        protected static $_descriptor;   

        /** @var \Closure[] */
        protected static $__extensions = array();


        public static function descriptor()
        {
            $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'tests.Complex');

             
            // optional enum enum = 1 
            $f = new \DrSlump\Protobuf\Field();
            $f->number = 1;
            $f->name   = "enum";
            $f->rule   = \DrSlump\Protobuf::RULE_OPTIONAL;
            $f->type   = \DrSlump\Protobuf::TYPE_ENUM;
             
            $f->reference = '\tests\Complex\Enum';

            $descriptor->addField($f);
             
            // optional message nested = 2 
            $f = new \DrSlump\Protobuf\Field();
            $f->number = 2;
            $f->name   = "nested";
            $f->rule   = \DrSlump\Protobuf::RULE_OPTIONAL;
            $f->type   = \DrSlump\Protobuf::TYPE_MESSAGE;
             
            $f->reference = '\tests\Complex\Nested';

            $descriptor->addField($f);
            
            foreach (self::$__extensions as $cb) {
                $descriptor->addField($cb(), true);
            }

            return $descriptor;
        }


                
        /**
         * Check if "enum" has a value
         *
         * @return boolean
         */
        public function hasEnum()
        {
            return isset($this->enum);
        }

        /**
         * Clear "enum" value
         */
        public function clearEnum()
        {
            unset($this->enum);
        }

        
        /**
         * Get "enum" value
         *
         * @return int - tests\Complex\Enum 
         */
        public function getEnum()
        {
            return $this->enum;
        }

        /**
         * Set "enum" value
         *
         * @param int - tests\Complex\Enum $value
         */
        public function setEnum($value)
        {
            return $this->enum = $value;
        }

        
                
        /**
         * Check if "nested" has a value
         *
         * @return boolean
         */
        public function hasNested()
        {
            return isset($this->nested);
        }

        /**
         * Clear "nested" value
         */
        public function clearNested()
        {
            unset($this->nested);
        }

        
        /**
         * Get "nested" value
         *
         * @return tests\Complex\Nested 
         */
        public function getNested()
        {
            return $this->nested;
        }

        /**
         * Set "nested" value
         *
         * @param tests\Complex\Nested $value
         */
        public function setNested($value)
        {
            return $this->nested = $value;
        }
    }
}


namespace tests\Complex {

            class Enum extends \DrSlump\Protobuf\Enum
    {
                const FOO = 1;
                const BAR = 2;
                const BAZ = 10;
    }
}
 

namespace tests\Complex {

         
    class Nested extends \DrSlump\Protobuf\Message {
                             
        /** @var \DrSlump\Protobuf\Descriptor */
        protected static $_descriptor;   

        /** @var \Closure[] */
        protected static $__extensions = array();


        public static function descriptor()
        {
            $descriptor = new \DrSlump\Protobuf\Descriptor(__CLASS__, 'tests.Complex.Nested');

             
            // optional string foo = 1 
            $f = new \DrSlump\Protobuf\Field();
            $f->number = 1;
            $f->name   = "foo";
            $f->rule   = \DrSlump\Protobuf::RULE_OPTIONAL;
            $f->type   = \DrSlump\Protobuf::TYPE_STRING;

            $descriptor->addField($f);
            
            foreach (self::$__extensions as $cb) {
                $descriptor->addField($cb(), true);
            }

            return $descriptor;
        }


                
        /**
         * Check if "foo" has a value
         *
         * @return boolean
         */
        public function hasFoo()
        {
            return isset($this->foo);
        }

        /**
         * Clear "foo" value
         */
        public function clearFoo()
        {
            unset($this->foo);
        }

        
        /**
         * Get "foo" value
         *
         * @return string 
         */
        public function getFoo()
        {
            return $this->foo;
        }

        /**
         * Set "foo" value
         *
         * @param string $value
         */
        public function setFoo($value)
        {
            return $this->foo = $value;
        }
    }
}


